Microsoft Windows [Version 6.3.9600]
(c) 2013 Microsoft Corporation. All rights reserved.

D:\Desktop\PPT>python --version
Python 3.7.6

D:\Desktop\PPT>mkdir handson

D:\Desktop\PPT>cd  handson

D:\Desktop\PPT\handson>dir
 Volume in drive D is LENOVO
 Volume Serial Number is 0299-ED51

 Directory of D:\Desktop\PPT\handson

17-08-2020  10:19    <DIR>          .
17-08-2020  10:19    <DIR>          ..
               0 File(s)              0 bytes
               2 Dir(s)   5,900,382,208 bytes free

D:\Desktop\PPT\handson>echo > first.py

D:\Desktop\PPT\handson>dir
 Volume in drive D is LENOVO
 Volume Serial Number is 0299-ED51

 Directory of D:\Desktop\PPT\handson

17-08-2020  10:21    <DIR>          .
17-08-2020  10:21    <DIR>          ..
17-08-2020  10:21                13 first.py
               1 File(s)             13 bytes
               2 Dir(s)   5,900,382,208 bytes free

D:\Desktop\PPT\handson>python first.py
a= 1

D:\Desktop\PPT\handson>python
Python 3.7.6 (tags/v3.7.6:43364a7ae0, Dec 19 2019, 00:42:30) [MSC v.1916 64 bit (AMD64)] on win32
Type "help", "copyright", "credits" or "license" for more information.
>>> a = 1
>>> type(a)
<class 'int'>
>>> f = 1.2
>>> type(f)
<class 'float'>
>>> b = True
>>> type(b)
<class 'bool'>
>>> s = "OK"
>>> type(s)
<class 'str'>
>>> True
True
>>> False
False
>>> b = a + 1
>>> type(b)
<class 'int'>
>>> f * 3
3.5999999999999996
>>> from   __future__  import print_function, division
>>> a / 2
0.5
>>> a // 2
0
>>> a % 2
1
>>> a == 1
True
>>> s == "OK"
True
>>> s != "OK"
False
>>> a , "a"
(1, 'a')
>>> "hello_world"
'hello_world'
>>> quit()

D:\Desktop\PPT\handson>python first.py
a= 1
Equal

D:\Desktop\PPT\handson>python first.py
a= 1
Equal
Another line
third line

D:\Desktop\PPT\handson>python first.py
a= 1
Equal
Another line
third line

D:\Desktop\PPT\handson>python first.py
not known

D:\Desktop\PPT\handson>python first.py
OK

D:\Desktop\PPT\handson>python first.py
Give Name: XYZ
OK

D:\Desktop\PPT\handson>python first.py
Give Name: ABC
Give Age: 40
not known

D:\Desktop\PPT\handson>python first.py
Give Name: XYZ
Give Age: 30
Traceback (most recent call last):
  File "first.py", line 30, in <module>
    if age < 40:
TypeError: '<' not supported between instances of 'str' and 'int'

D:\Desktop\PPT\handson>python
Python 3.7.6 (tags/v3.7.6:43364a7ae0, Dec 19 2019, 00:42:30) [MSC v.1916 64 bit (AMD64)] on win32
Type "help", "copyright", "credits" or "license" for more information.
>>> s = "1"
>>> i = 1
>>> type(i)
<class 'int'>
>>> int(s)
1
>>> str(i)
'1'
>>> float(s)
1.0
>>> type(2.3)
<class 'float'>
>>> str(1.2)
'1.2'
>>> quit()

D:\Desktop\PPT\handson>python first.py
Give Name: XYZ
Give Age: 40
OK

D:\Desktop\PPT\handson>echo > string_examples.py

D:\Desktop\PPT\handson>python
Python 3.7.6 (tags/v3.7.6:43364a7ae0, Dec 19 2019, 00:42:30) [MSC v.1916 64 bit (AMD64)] on win32
Type "help", "copyright", "credits" or "license" for more information.
>>> s = "Hello World"
>>> s = 'Hello World'
>>> s = """Hello
... World"""
>>> s
'Hello\nWorld'
>>> len(s)
11
>>> s[0]
'H'
>>> s[len(s)-1]
'd'
>>> s[-1]
'd'
>>> s[-lens(s)]
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'lens' is not defined
>>> s[-len(s)]
'H'
>>> "He" in s
True
>>> "He" not in s
False
>>> s == "OK"
False
>>> for each_char in s:
...     print(each_char)
...
H
e
l
l
o


W
o
r
l
d
>>> for e in s:
...     print(e)
...
H
e
l
l
o


W
o
r
l
d
>>> #initialize a
>>> a = 0
>>> #increment a
>>> a = a + 1
>>> quit()

D:\Desktop\PPT\handson>python string_examples.py
H - 1
e - 1
l - 3
l - 3
o - 2
  - 1
W - 1
o - 2
r - 1
l - 3
d - 1

D:\Desktop\PPT\handson>python string_examples.py
  File "string_examples.py", line 36
    print(ch1, "-", counter)
                               ^
IndentationError: unindent does not match any outer indentation level

D:\Desktop\PPT\handson>python string_examples.py
H - 1
e - 1
l - 3
l - 3
o - 2
  - 1
W - 1
o - 2
r - 1
l - 3
d - 1

D:\Desktop\PPT\handson>python
Python 3.7.6 (tags/v3.7.6:43364a7ae0, Dec 19 2019, 00:42:30) [MSC v.1916 64 bit (AMD64)] on win32
Type "help", "copyright", "credits" or "license" for more information.
>>> s = "Hello"
>>> s[0]
'H'
>>> s[0] = 'K'
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'str' object does not support item assignment
>>> s2 = s + " World"
>>> s2
'Hello World'
>>> s
'Hello'
>>> s * 4
'HelloHelloHelloHello'
>>> s2
'Hello World'
>>> s2[0:5]  # start: end: step
'Hello'
>>> s2[0], s2[1], s2[2], s2[3], s2[4]
('H', 'e', 'l', 'l', 'o')
>>> s2[0:5:2]  # start: end: step
'Hlo'
>>> s2[0], s2[2], s2[4]
('H', 'l', 'o')
>>> s[:]
'Hello'
>>> s[::-1]
'olleH'
>>> s[::2]
'Hlo'
>>> for e in s[::-1]:
...     print(e)
...
o
l
l
e
H
>>> for e in s[::2]:
...     print(e)
...
H
l
o
>>> print(s[::-1])
olleH
>>> quit()

D:\Desktop\PPT\handson>python
Python 3.7.6 (tags/v3.7.6:43364a7ae0, Dec 19 2019, 00:42:30) [MSC v.1916 64 bit (AMD64)] on win32
Type "help", "copyright", "credits" or "license" for more information.
>>> s="HELLO WORLD"
>>> s[5:0:-1]
' OLLE'
>>> s[::-1]
'DLROW OLLEH'
>>> type(s)
<class 'str'>
>>> dir(str)
['__add__', '__class__', '__contains__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__'
, '__getattribute__', '__getitem__', '__getnewargs__', '__gt__', '__hash__', '__init__', '__init_subclass__',
'__iter__', '__le__', '__len__', '__lt__', '__mod__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_
ex__', '__repr__', '__rmod__', '__rmul__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 'capita
lize', 'casefold', 'center', 'count', 'encode', 'endswith', 'expandtabs', 'find', 'format', 'format_map', 'ind
ex', 'isalnum', 'isalpha', 'isascii', 'isdecimal', 'isdigit', 'isidentifier', 'islower', 'isnumeric', 'isprint
able', 'isspace', 'istitle', 'isupper', 'join', 'ljust', 'lower', 'lstrip', 'maketrans', 'partition', 'replace
', 'rfind', 'rindex', 'rjust', 'rpartition', 'rsplit', 'rstrip', 'split', 'splitlines', 'startswith', 'strip',
 'swapcase', 'title', 'translate', 'upper', 'zfill']
>>> len(s)
11
>>> s
'HELLO WORLD'
>>> help(str.strip)
Help on method_descriptor:

strip(self, chars=None, /)
    Return a copy of the string with leading and trailing whitespace removed.

    If chars is given and not None, remove characters in chars instead.

>>> s = "    OK    "
>>> s.strip()
'OK'
>>> len(s)
10
>>> help(str.split)
Help on method_descriptor:

split(self, /, sep=None, maxsplit=-1)
    Return a list of the words in the string, using sep as the delimiter string.

    sep
      The delimiter according which to split the string.
      None (the default value) means split according to any whitespace,
      and discard empty strings from the result.
    maxsplit
      Maximum number of splits to do.
      -1 (the default value) means no limit.

>>> s1 = "A:B:C"
>>> s1.split(":")
['A', 'B', 'C']
>>> s="HELLO WORLD"
>>> dir(str)
['__add__', '__class__', '__contains__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__'
, '__getattribute__', '__getitem__', '__getnewargs__', '__gt__', '__hash__', '__init__', '__init_subclass__',
'__iter__', '__le__', '__len__', '__lt__', '__mod__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_
ex__', '__repr__', '__rmod__', '__rmul__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 'capita
lize', 'casefold', 'center', 'count', 'encode', 'endswith', 'expandtabs', 'find', 'format', 'format_map', 'ind
ex', 'isalnum', 'isalpha', 'isascii', 'isdecimal', 'isdigit', 'isidentifier', 'islower', 'isnumeric', 'isprint
able', 'isspace', 'istitle', 'isupper', 'join', 'ljust', 'lower', 'lstrip', 'maketrans', 'partition', 'replace
', 'rfind', 'rindex', 'rjust', 'rpartition', 'rsplit', 'rstrip', 'split', 'splitlines', 'startswith', 'strip',
 'swapcase', 'title', 'translate', 'upper', 'zfill']
>>> help(str.strip)
Help on method_descriptor:

strip(self, chars=None, /)
    Return a copy of the string with leading and trailing whitespace removed.

    If chars is given and not None, remove characters in chars instead.

>>> s.strip()
'HELLO WORLD'
>>> len(s)
11
>>> help(str.split)
Help on method_descriptor:

split(self, /, sep=None, maxsplit=-1)
    Return a list of the words in the string, using sep as the delimiter string.

    sep
      The delimiter according which to split the string.
      None (the default value) means split according to any whitespace,
      and discard empty strings from the result.
    maxsplit
      Maximum number of splits to do.
      -1 (the default value) means no limit.

>>> s1 = "A:B:C"
>>> s1.split(":")
['A', 'B', 'C']
>>> help(str.endswith)
Help on method_descriptor:

endswith(...)
    S.endswith(suffix[, start[, end]]) -> bool

    Return True if S ends with the specified suffix, False otherwise.
    With optional start, test S beginning at that position.
    With optional end, stop comparing S at that position.
    suffix can also be a tuple of strings to try.

>>> s
'HELLO WORLD'
>>> s.endswith("LD")
True
>>> s1="hello world"
>>> s2 = "     ABCD,CDEF   "
>>> s2.split(",")
['     ABCD', 'CDEF   ']
>>> tmp = s2.strip()
>>> out = tmp.split(",")
>>> out
['ABCD', 'CDEF']
>>> s2.strip().split(",")
['ABCD', 'CDEF']
>>> lst = [ 1, 2.3, "ok", [1,2,3]]
>>> el = []
>>> type(el)
<class 'list'>
>>> len(lst)
4
>>> lst[0]
1
>>> lst[-1]
[1, 2, 3]
>>> lst[-1] = 30
>>> lst
[1, 2.3, 'ok', 30]
>>> 2.3 in lst
True
>>> 2.4 not in lst
True
>>> lst == [1,2,3]
False
>>> for e in lst:
...     print(e)
...
1
2.3
ok
30
>>> lst[0:3]
[1, 2.3, 'ok']
>>> lst[0:3:2]
[1, 'ok']
>>> lst[::-1]
[30, 'ok', 2.3, 1]
>>> lst[::2]
[1, 'ok']
>>>
>>> el
[]
>>> s=[ 1,2,3,4,5,6,7,8]
>>> s[5:0:-1]
[6, 5, 4, 3, 2]
>>> s[::-1]
[8, 7, 6, 5, 4, 3, 2, 1]
>>> lst = [1,2,3]
>>> lst.append(30)
>>> lst
[1, 2, 3, 30]
>>> lst.append(40)
>>> lst
[1, 2, 3, 30, 40]
>>> el.append("OK")
>>> el
['OK']
>>> quit()

D:\Desktop\PPT\handson>echo > list_examples.py

D:\Desktop\PPT\handson>python list_examples.py
  File "list_examples.py", line 8
    from e in input:
            ^
SyntaxError: invalid syntax

D:\Desktop\PPT\handson>python list_examples.py
[9, 25, 4, 100]

D:\Desktop\PPT\handson>python
Python 3.7.6 (tags/v3.7.6:43364a7ae0, Dec 19 2019, 00:42:30) [MSC v.1916 64 bit (AMD64)] on win32
Type "help", "copyright", "credits" or "license" for more information.
>>> input = "[1,2,3,4]"
>>> output = [1,2,3,4]
>>> #s2 = Strip with "[]" and then split with ","
>>> input.strip("[]")
'1,2,3,4'
>>> tmp = input.strip("[]")
>>> tmp.split(",")
['1', '2', '3', '4']
>>> input.strip("[]").split(",")
['1', '2', '3', '4']
>>> s2 = input.strip("[]").split(",")
>>> output = []
>>> for e in s2:
...     output.append( int(e) )
...
>>> output
[1, 2, 3, 4]
>>> Sinput=input.split(input.strip("[]"),",")
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'str' object cannot be interpreted as an integer
>>> input.strip("[]")
'1,2,3,4'
>>>
>>>
>>> lst = [1,2,3,4]
>>> lst2 = lst + [30,40]
>>> lst2
[1, 2, 3, 4, 30, 40]
>>> lst
[1, 2, 3, 4]
>>> lst3 = [30,40] + lst
>>> lst3
[30, 40, 1, 2, 3, 4]
>>> lst
[1, 2, 3, 4]
>>> lst * 4
[1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]
>>> dir(list)
['__add__', '__class__', '__contains__', '__delattr__', '__delitem__', '__dir__', '__doc__', '__eq__', '__form
at__', '__ge__', '__getattribute__', '__getitem__', '__gt__', '__hash__', '__iadd__', '__imul__', '__init__',
'__init_subclass__', '__iter__', '__le__', '__len__', '__lt__', '__mul__', '__ne__', '__new__', '__reduce__',
'__reduce_ex__', '__repr__', '__reversed__', '__rmul__', '__setattr__', '__setitem__', '__sizeof__', '__str__'
, '__subclasshook__', 'append', 'clear', 'copy', 'count', 'extend', 'index', 'insert', 'pop', 'remove', 'rever
se', 'sort']
>>>
>>>
>>> lst = [ [1,2], [3,4], [5,6]]
>>> type(lst)
<class 'list'>
>>> type(lst[0])
<class 'list'>
>>> for e in lst:
...     print(e[0])
...
1
3
5
>>> e[0]
5
>>> lst[0]
[1, 2]
>>> lst = [ [1,2], [3,4], [5,6]]
>>> lst[-1]
[5, 6]
>>> tmp = lst[-1]
>>> tmp[-1]
6
>>> lst[-1][-1]
6
>>> lst[-1][-1] = lst[-1][-1] + 1
>>> lst
[[1, 2], [3, 4], [5, 7]]
>>> o = []
>>> for e in lst:
...     o.append( [e[0], e[-1]+1] )
...
>>> o
[[1, 3], [3, 5], [5, 8]]
>>>
>>> t = (1,2,3)
>>> et = ()
>>> type(et)
<class 'tuple'>
>>> len(t)
3
>>> 3 in t
True
>>> t[0]
1
>>> t[0] = 3
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'tuple' object does not support item assignment
>>> for e in t:
...     print(e)
...
1
2
3
>>> t.append(30)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: 'tuple' object has no attribute 'append'
>>> dir(tuple)
['__add__', '__class__', '__contains__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__'
, '__getattribute__', '__getitem__', '__getnewargs__', '__gt__', '__hash__', '__init__', '__init_subclass__',
'__iter__', '__le__', '__len__', '__lt__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__r
epr__', '__rmul__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 'count', 'index']
>>> dir(list)
['__add__', '__class__', '__contains__', '__delattr__', '__delitem__', '__dir__', '__doc__', '__eq__', '__form
at__', '__ge__', '__getattribute__', '__getitem__', '__gt__', '__hash__', '__iadd__', '__imul__', '__init__',
'__init_subclass__', '__iter__', '__le__', '__len__', '__lt__', '__mul__', '__ne__', '__new__', '__reduce__',
'__reduce_ex__', '__repr__', '__reversed__', '__rmul__', '__setattr__', '__setitem__', '__sizeof__', '__str__'
, '__subclasshook__', 'append', 'clear', 'copy', 'count', 'extend', 'index', 'insert', 'pop', 'remove', 'rever
se', 'sort']
>>> t
(1, 2, 3)
>>> t2 = t + (20,30)
>>> t2
(1, 2, 3, 20, 30)
>>> t
(1, 2, 3)
>>> lst
[[1, 2], [3, 4], [5, 7]]
>>> t3 = tuple(lst)
>>> t3
([1, 2], [3, 4], [5, 7])
>>> t3[-1].append(20)
>>> t3
([1, 2], [3, 4], [5, 7, 20])
>>> t3[-1] = [23,30]
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'tuple' object does not support item assignment
>>> lst
[[1, 2], [3, 4], [5, 7, 20]]
>>> o = ()
>>> o = []
>>> for e in lst:
...     o.append( tuple (e) )
...
>>> o
[(1, 2), (3, 4), (5, 7, 20)]
>>> o[-1].append(70)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: 'tuple' object has no attribute 'append'
>>> o[-1] = (30,40)
>>> o
[(1, 2), (3, 4), (30, 40)]
>>> [1,1,1,1,2]
[1, 1, 1, 1, 2]
>>> [1,2,3]
[1, 2, 3]
>>>
>>>
>>> s1 = {1,1,1,1,2]
  File "<stdin>", line 1
    s1 = {1,1,1,1,2]
                   ^
SyntaxError: invalid syntax
>>> s1 = {1,1,1,1,2}
>>> s1
{1, 2}
>>> lst = [1,2,3,4,2,3,4]
>>> set(lst)
{1, 2, 3, 4}
>>> list(set(lst))
[1, 2, 3, 4]
>>> #set - Duplicates - NP, Indexing-NP, Insertion ordered-NP, Mutable
>>> s = {1,2,3}
>>> es = set()  # it is not {}
>>> type(es)
<class 'set'>
>>> len(s)
3
>>> 2 in s
True
>>> s == {3,2,1}
True
>>> for e in s:
...     print(e)
...
1
2
3
>>> s = {3,2,1}
>>> for e in s:
...     print(e)
...
1
2
3
>>> quit()

D:\Desktop\PPT\handson>python string_examples.py
H - 1
e - 1
l - 3
l - 3
o - 2
  - 1
W - 1
o - 2
r - 1
l - 3
d - 1

D:\Desktop\PPT\handson>python string_examples.py
W - 1
  - 1
e - 1
r - 1
H - 1
d - 1
o - 2
l - 3

D:\Desktop\PPT\handson>python
Python 3.7.6 (tags/v3.7.6:43364a7ae0, Dec 19 2019, 00:42:30) [MSC v.1916 64 bit (AMD64)] on win32
Type "help", "copyright", "credits" or "license" for more information.
>>> s = {1,2,3}
>>> es = set()  # it is not {}
>>> type(es)
<class 'set'>
>>> len(s)
3
>>> 2 in s
True
>>> s == {3,2,1}
True
>>> for e in s:
...     print(e)
...
1
2
3
>>> #set - Duplicates - NP, Indexing-NP, Insertion ordered-NP, Mutable
>>> s[0]
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'set' object is not subscriptable
>>> s.append(30)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: 'set' object has no attribute 'append'
>>> s.add(30)
>>> s
{1, 2, 3, 30}
>>> s1 = {1,2,3,4}
>>> s2 = {4,5,6,7}
>>> s1 | s2
{1, 2, 3, 4, 5, 6, 7}
>>> s1 & s2
{4}
>>> s1 ^ s2
{1, 2, 3, 5, 6, 7}
>>> s1 - s2
{1, 2, 3}
>>> (s1-s2) | (s2-s1)
{1, 2, 3, 5, 6, 7}
>>> s = "OK"
>>> rs = r"OK"
>>> su = u"OK"
>>> sb = b"OK"
>>> type(rs), type(su), type(sb)
(<class 'str'>, <class 'str'>, <class 'bytes'>)
>>> len(r"\n")
2
>>> len("\n")
1
>>> len(r"\n\n")
4
>>> len("\n\n")
2
>>> s = "OK"
>>> s.encode("utf-8")
b'OK'
>>> sb.decode("utf-8")
'OK'
>>> dir(bytes)
['__add__', '__class__', '__contains__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__'
, '__getattribute__', '__getitem__', '__getnewargs__', '__gt__', '__hash__', '__init__', '__init_subclass__',
'__iter__', '__le__', '__len__', '__lt__', '__mod__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_
ex__', '__repr__', '__rmod__', '__rmul__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 'capita
lize', 'center', 'count', 'decode', 'endswith', 'expandtabs', 'find', 'fromhex', 'hex', 'index', 'isalnum', 'i
salpha', 'isascii', 'isdigit', 'islower', 'isspace', 'istitle', 'isupper', 'join', 'ljust', 'lower', 'lstrip',
 'maketrans', 'partition', 'replace', 'rfind', 'rindex', 'rjust', 'rpartition', 'rsplit', 'rstrip', 'split', '
splitlines', 'startswith', 'strip', 'swapcase', 'title', 'translate', 'upper', 'zfill']
>>> dir(str)
['__add__', '__class__', '__contains__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__'
, '__getattribute__', '__getitem__', '__getnewargs__', '__gt__', '__hash__', '__init__', '__init_subclass__',
'__iter__', '__le__', '__len__', '__lt__', '__mod__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_
ex__', '__repr__', '__rmod__', '__rmul__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 'capita
lize', 'casefold', 'center', 'count', 'encode', 'endswith', 'expandtabs', 'find', 'format', 'format_map', 'ind
ex', 'isalnum', 'isalpha', 'isascii', 'isdecimal', 'isdigit', 'isidentifier', 'islower', 'isnumeric', 'isprint
able', 'isspace', 'istitle', 'isupper', 'join', 'ljust', 'lower', 'lstrip', 'maketrans', 'partition', 'replace
', 'rfind', 'rindex', 'rjust', 'rpartition', 'rsplit', 'rstrip', 'split', 'splitlines', 'startswith', 'strip',
 'swapcase', 'title', 'translate', 'upper', 'zfill']
>>> sb.decode("utf-16")
'䭏'
>>> s.encode("utf-16")
b'\xff\xfeO\x00K\x00'
>>> s.encode("utf-16").decode("utf-16")
'OK'
>>> s.encode("utf-16").decode("utf-8")
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
UnicodeDecodeError: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte
>>> set(dir(bytes)) - set(dir(str))
{'hex', 'fromhex', 'decode'}
>>> set(dir(str)) - set(dir(bytes))
{'isdecimal', 'format', 'isidentifier', 'encode', 'isnumeric', 'isprintable', 'casefold', 'format_map'}
>>> set(dir(str)) ^ set(dir(bytes))
{'format', 'isdecimal', 'fromhex', 'casefold', 'isnumeric', 'encode', 'format_map', 'isprintable', 'decode', '
hex', 'isidentifier'}
>>> help(str.encode)
Help on method_descriptor:

encode(self, /, encoding='utf-8', errors='strict')
    Encode the string using the codec registered for encoding.

    encoding
      The encoding in which to encode the string.
    errors
      The error handling scheme to use for encoding errors.
      The default is 'strict' meaning that encoding errors raise a
      UnicodeEncodeError.  Other possible values are 'ignore', 'replace' and
      'xmlcharrefreplace' as well as any other name registered with
      codecs.register_error that can handle UnicodeEncodeErrors.

>>> bytes
<class 'bytes'>
>>> str
<class 'str'>
>>> "ok".encode("utf-8")
b'ok'
>>>
>>>
>>> # Can you create list of sets where each set contains two numbers
>>> [{1, 2}, {3, 4}, {5, 6}]
[{1, 2}, {3, 4}, {5, 6}]
>>> # Can you create set of lists where each list contains two numbers
>>> {[1,2],[3,4],[5,6]}
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: unhashable type: 'list'
>>> {1,1,1,1,2}
{1, 2}
>>> hash(1)
1
>>> hash( "OK" )
-7424137150128442415
>>> hash( (1,2) )
3713081631934410656
>>> hash( [1,2] )
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: unhashable type: 'list'
>>> {(1,2),(3,4),(5,6)}
{(1, 2), (3, 4), (5, 6)}
>>>
